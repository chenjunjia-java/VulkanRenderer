#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform PBRUniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
    vec4 directionalLightDir;
    vec4 directionalLightColor;
    vec4 directionalLightParams;
    vec4 lightPositions[3];
    vec4 lightColors[3];
    vec4 camPos;
    vec4 params;
    vec4 iblParams;
    vec4 rtaoParams0;
    vec4 rtaoParams1;
    mat4 prevViewProj;
} ubo;

layout(binding = 1) uniform sampler2D depthResolve;
layout(binding = 2) uniform sampler2D normalResolve;
layout(binding = 6) uniform sampler2D aoPing0;
layout(binding = 7) uniform sampler2D aoPing1;
layout(binding = 10, r16f) uniform image2D aoFullOut;

layout(push_constant) uniform PushParams {
    uint width;
    uint height;
    uint step;
    uint iteration;
} pc;

void main()
{
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= int(pc.width) || pix.y >= int(pc.height)) {
        return;
    }

    uint srcIdx = pc.iteration & 1u;

    vec2 uv = (vec2(pix) + 0.5) / vec2(pc.width, pc.height);
    vec3 centerN = normalize(texture(normalResolve, uv).xyz * 2.0 - 1.0);
    uint debugMode = uint(ubo.iblParams.w + 0.5);
    if (debugMode == 9u) {
        // Debug: visualize normal.y (up-facing surfaces should be bright).
        float ny = clamp(centerN.y * 0.5 + 0.5, 0.0, 1.0);
        imageStore(aoFullOut, pix, vec4(ny, 0.0, 0.0, 0.0));
        return;
    }

    // Full-res path: no upsampling needed, just write the selected denoised buffer to the final output.
    ivec2 clampedPix = clamp(pix, ivec2(0), ivec2(textureSize(aoPing0, 0)) - ivec2(1));
    float ao = (srcIdx == 0u) ? texelFetch(aoPing0, clampedPix, 0).r : texelFetch(aoPing1, clampedPix, 0).r;
    imageStore(aoFullOut, pix, vec4(ao, 0.0, 0.0, 0.0));
}

